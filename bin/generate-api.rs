//! gear node api generator.
use std::{
    fs::{self, File},
    io::{self, Write},
    path::PathBuf,
    process::{Command, Stdio},
    thread,
    time::Duration,
};
use structopt::StructOpt;

const GENERATED_API_HEADER: &str = r#"
//! Auto generated by subxt-cli
//!
//! subxt codegen | rustfmt --edition=2021
//!
//! spec_version: ${SPEC_VERSION}
#![allow(clippy::all)]
"#;
const SPEC_VERSION_PATT: &str = "${SPEC_VERSION}";
const DOCKER_REPO: &str = "ghcr.io/gear-tech/node";
const GEAR_NODE_BIN: &str = "/usr/local/bin/gear-node";

#[derive(Debug, StructOpt)]
struct Opt {
    /// Docker image of gear-node.
    #[structopt(default_value = "ghcr.io/gear-tech/node", short, long)]
    image: String,
    /// gear-node binary in the docker image.
    #[structopt(default_value = "/usr/local/bin/gear-node", short, long)]
    bin: String,
    /// gear-node websocket port.
    #[structopt(default_value = "9944", short, long)]
    port: u16,
}

// /// Generate gear api
// ///
// /// subxt codegen | rustfmt --edition=2021
// fn main() -> Result<(), String> {
//     let (mut subxt_cli, mut rustfmt) = (Command::new("subxt"), Command::new("rustfmt"));
//
//     let mut ps = Command::new("docker")
//         .args(&[
//             "run",
//             "-it",
//             DOCKER_REPO,
//             GEAR_NODE_BIN,
//             "--tmp",
//             "--dev",
//             "--ws-port",
//             &ws.to_string(),
//         ])
//         .stdout(Stdio::piped())
//         .stderr(Stdio::piped())
//         .spawn();
//
//     thread::sleep(Duration::from_secs(5));
//
//     let pre_generated = subxt_cli
//         .args(["codegen"])
//         .output()
//         .expect("subxt not found, please run cargo install subxt-cli");
//
//     if !pre_generated.stderr.is_empty() {
//         panic!("{}", String::from_utf8_lossy(&pre_generated.stderr));
//     }
//
//     // Pipe generated code to rustfmt.
//     let mut fmt = rustfmt
//         .args(["--edition=2021"])
//         .stdin(Stdio::piped())
//         .stdout(Stdio::piped())
//         .spawn()
//         .expect("Failed to spawn rustfmt");
//     let mut stdin = fmt.stdin.take().expect("failed to open stdin of rustfmt");
//
//     thread::spawn(move || {
//         stdin
//             .write_all(&pre_generated.stdout)
//             .expect("Failed to write to stdin of rustfmt")
//     });
//
//     // Prepare header.
//     let header = GENERATED_API_HEADER.replace(SPEC_VERSION_PATT, &spec_version.to_string());
//     let fmt_output = fmt
//         .wait_with_output()
//         .expect("Failed to read stdout of rustfmt");
//
//     if !fmt_output.stderr.is_empty() {
//         panic!("{}", String::from_utf8_lossy(&fmt_output.stderr));
//     }
//
//     // Concat generated api.
//     let generated = [header.trim_start().as_bytes(), &fmt_output.stdout].concat();
//     let target = self.api.join(paths::GENERATED_RS);
//     fs::write(target, generated)?;
//
//     ps.kill()?;
//     Ok(())
// }
