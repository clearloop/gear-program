use crate::builder::{node::Node, paths, utils};
use std::{
    fs::{self, File},
    io::{self, Write},
    path::PathBuf,
    process::{Command, Stdio},
    thread,
    time::Duration,
};

const GENERATED_API_HEADER: &str = r#"
//! Auto generated by subxt-cli
//!
//! subxt codegen | rustfmt --edition=2021
//!
//! spec_version: ${SPEC_VERSION}
#![allow(clippy::all)]
"#;
const SPEC_VERSION_PATT: &str = "${SPEC_VERSION}";

/// Unexpected spec_version \[expected, actual\].
pub type UnexpectedSpecVersion = (u32, u32);

/// API builder
///
/// - Fetch/Update the latest gear node.
/// - Generate api from the latest gear node.
/// - spec_version checking.
pub struct Pre {
    /// Path of the api module.
    pub api: PathBuf,
    /// Path of the gear submodule.
    pub gear: PathBuf,
}

impl Default for Pre {
    fn default() -> Self {
        let root = env!("CARGO_MANIFEST_DIR");

        Self {
            api: PathBuf::from(root).join(paths::API_MODULE),
            gear: PathBuf::from(root).join(paths::GEAR_SUBMODULE),
        }
    }
}

impl Pre {
    /// Build the gear node
    pub fn build_gear(&self) {
        let manifest = self.gear.join(paths::CARGO_TOML);
        let mut cargo = Command::new("cargo");

        cargo
            .args([
                "build",
                "--manifest-path",
                manifest
                    .as_os_str()
                    .to_str()
                    .expect("Invalid package manifest."),
                "--release",
            ])
            .status()
            .expect("Build gear node failed");
    }

    /// - fetch or update the gear submodule
    /// - check if the spec_version of client api is matched with
    ///   the lastest gear node
    pub fn check_spec_version(&self) -> Result<(), UnexpectedSpecVersion> {
        let mut git = Command::new("git");
        let mut args = vec!["submodule", "update"];

        let runtime_lib_path = self.gear.join(paths::RUNTIME_LIB_PATH);
        if runtime_lib_path.exists() {
            args.push("--remote");
        } else {
            args.push("--init");
        };

        git.args(&args)
            .status()
            .expect("Failed to update the gear submodule.");

        // get the spec_version from the gear submodule
        let (runtime_lib, api) = (
            File::open(runtime_lib_path).expect("Gear runtime library not found."),
            File::open(&self.api.join(paths::GENERATED_RS)).expect("Api module not found."),
        );

        let (runtime_version, api_version) = (
            utils::find_spec_version(&runtime_lib)
                .expect("Failed to get `spec_version` from gear runtime"),
            utils::find_spec_version(&api).unwrap_or(0),
        );

        if runtime_version == api_version {
            Ok(())
        } else {
            Err((runtime_version, api_version))
        }
    }

    /// Generate gear api
    ///
    /// subxt codegen | rustfmt --edition=2021
    pub fn generate_gear_api(&self, spec_version: u32) -> io::Result<()> {
        let (mut subxt_cli, mut rustfmt) = (Command::new("subxt"), Command::new("rustfmt"));

        let mut ps = Node::new(self.gear.join(paths::GEAR_BIN)).dev(9944)?;

        thread::sleep(Duration::from_secs(5));

        let pre_generated = subxt_cli
            .args(["codegen"])
            .output()
            .expect("subxt not found, please run cargo install subxt-cli");

        if !pre_generated.stderr.is_empty() {
            panic!("{}", String::from_utf8_lossy(&pre_generated.stderr));
        }

        // Pipe generated code to rustfmt.
        let mut fmt = rustfmt
            .args(["--edition=2021"])
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .spawn()
            .expect("Failed to spawn rustfmt");
        let mut stdin = fmt.stdin.take().expect("failed to open stdin of rustfmt");

        thread::spawn(move || {
            stdin
                .write_all(&pre_generated.stdout)
                .expect("Failed to write to stdin of rustfmt")
        });

        // Prepare header.
        let header = GENERATED_API_HEADER.replace(SPEC_VERSION_PATT, &spec_version.to_string());
        let fmt_output = fmt
            .wait_with_output()
            .expect("Failed to read stdout of rustfmt");

        if !fmt_output.stderr.is_empty() {
            panic!("{}", String::from_utf8_lossy(&fmt_output.stderr));
        }

        // Concat generated api.
        let generated = [header.trim_start().as_bytes(), &fmt_output.stdout].concat();
        let target = self.api.join(paths::GENERATED_RS);
        fs::write(target, generated)?;

        ps.kill()?;
        Ok(())
    }
}
